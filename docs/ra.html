<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Module ra</title>
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="EDoc">
</head>
<body bgcolor="white">
<div class="navbar"><a name="#navbar_top"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<hr>

<h1>Module ra</h1>
<ul class="index"><li><a href="#description">Description</a></li><li><a href="#types">Data Types</a></li><li><a href="#index">Function Index</a></li><li><a href="#functions">Function Details</a></li></ul>The primary module for interacting with ra nodes and clusters.


<h2><a name="description">Description</a></h2>The primary module for interacting with ra nodes and clusters.
<h2><a name="types">Data Types</a></h2>

<h3 class="typedecl"><a name="type-ra_cmd_ret">ra_cmd_ret()</a></h3>
<p><tt>ra_cmd_ret() = <a href="ra_node_proc.html#type-ra_cmd_ret">ra_node_proc:ra_cmd_ret()</a></tt></p>


<h2><a name="index">Function Index</a></h2>
<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#add_member-2">add_member/2</a></td><td>Add a ra node id to a ra cluster's membership configuration
  This commits a join command to the leader log.</td></tr>
<tr><td valign="top"><a href="#add_member-3">add_member/3</a></td><td></td></tr>
<tr><td valign="top"><a href="#cast-2">cast/2</a></td><td>Cast a message to a node
  This is the least reliable way to interact with a ra node.</td></tr>
<tr><td valign="top"><a href="#cast-3">cast/3</a></td><td>Cast a message to a node with a priority
  This is the least reliable way to interact with a ra node.</td></tr>
<tr><td valign="top"><a href="#consistent_query-2">consistent_query/2</a></td><td>Query the state machine
  This allows a caller to query the state machine by appending the query
  to the log and returning the result once applied.</td></tr>
<tr><td valign="top"><a href="#consistent_query-3">consistent_query/3</a></td><td></td></tr>
<tr><td valign="top"><a href="#delete_cluster-1">delete_cluster/1</a></td><td>Deletes a ra cluster in an orderly fashion
  This function commits and end of life command which after each node applies
  it will cause that node to shut down and delete all it's data.</td></tr>
<tr><td valign="top"><a href="#delete_cluster-2">delete_cluster/2</a></td><td></td></tr>
<tr><td valign="top"><a href="#delete_node-1">delete_node/1</a></td><td>Deletes a ra node
  The node is forcefully deleted.</td></tr>
<tr><td valign="top"><a href="#leave_and_delete_node-1">leave_and_delete_node/1</a></td><td></td></tr>
<tr><td valign="top"><a href="#leave_and_delete_node-2">leave_and_delete_node/2</a></td><td></td></tr>
<tr><td valign="top"><a href="#leave_and_delete_node-3">leave_and_delete_node/3</a></td><td></td></tr>
<tr><td valign="top"><a href="#leave_and_terminate-1">leave_and_terminate/1</a></td><td></td></tr>
<tr><td valign="top"><a href="#leave_and_terminate-2">leave_and_terminate/2</a></td><td></td></tr>
<tr><td valign="top"><a href="#leave_and_terminate-3">leave_and_terminate/3</a></td><td></td></tr>
<tr><td valign="top"><a href="#local_query-2">local_query/2</a></td><td>query the machine state on any node
  This allows you to run the QueryFun over the node machine state and
  return the result.</td></tr>
<tr><td valign="top"><a href="#local_query-3">local_query/3</a></td><td></td></tr>
<tr><td valign="top"><a href="#members-1">members/1</a></td><td>Query the members of a cluster.</td></tr>
<tr><td valign="top"><a href="#members-2">members/2</a></td><td></td></tr>
<tr><td valign="top"><a href="#overview-0">overview/0</a></td><td>return a map of overview data of the ra system on the current erlang
  node.</td></tr>
<tr><td valign="top"><a href="#remove_member-2">remove_member/2</a></td><td>Removes a node from the cluster's membership configuration
  This function returns after appending the command to the log.</td></tr>
<tr><td valign="top"><a href="#remove_member-3">remove_member/3</a></td><td></td></tr>
<tr><td valign="top"><a href="#restart_node-1">restart_node/1</a></td><td>Restarts a previously succesfully started ra node.</td></tr>
<tr><td valign="top"><a href="#send-2">send/2</a></td><td></td></tr>
<tr><td valign="top"><a href="#send-3">send/3</a></td><td>send a command to the ra node.</td></tr>
<tr><td valign="top"><a href="#send_and_await_consensus-2">send_and_await_consensus/2</a></td><td></td></tr>
<tr><td valign="top"><a href="#send_and_await_consensus-3">send_and_await_consensus/3</a></td><td>send a command to the ra node.</td></tr>
<tr><td valign="top"><a href="#send_and_notify-3">send_and_notify/3</a></td><td>send a command to the ra node using cast.</td></tr>
<tr><td valign="top"><a href="#send_and_notify-4">send_and_notify/4</a></td><td></td></tr>
<tr><td valign="top"><a href="#start-0">start/0</a></td><td>Starts the ra application.</td></tr>
<tr><td valign="top"><a href="#start_cluster-3">start_cluster/3</a></td><td>Starts a new distributed ra cluster.</td></tr>
<tr><td valign="top"><a href="#start_node-1">start_node/1</a></td><td>Starts a ra node.</td></tr>
<tr><td valign="top"><a href="#start_node-4">start_node/4</a></td><td></td></tr>
<tr><td valign="top"><a href="#start_or_restart_cluster-3">start_or_restart_cluster/3</a></td><td>Starts or restarts a ra cluster.</td></tr>
<tr><td valign="top"><a href="#stop_node-1">stop_node/1</a></td><td>Stops a ra node.</td></tr>
<tr><td valign="top"><a href="#trigger_election-1">trigger_election/1</a></td><td>Causes the node to entre the pre-vote and attempt become leader
  It is necessary to call this function when starting a new cluster as a
  branch new ra node will not automatically enter pre-vote by itself.</td></tr>
<tr><td valign="top"><a href="#trigger_election-2">trigger_election/2</a></td><td></td></tr>
</table>

<h2><a name="functions">Function Details</a></h2>

<h3 class="function"><a name="add_member-2">add_member/2</a></h3>
<div class="spec">
<p><tt>add_member(ServerRef::<a href="#type-ra_node_id">ra_node_id()</a>, NodeId::<a href="#type-ra_node_id">ra_node_id()</a>) -&gt; <a href="#type-ra_cmd_ret">ra_cmd_ret()</a></tt><br></p>
<p><tt>ServerRef</tt>: the ra node to send the command to<br>
<tt>NodeId</tt>: the ra node id of the new node<br>
</p>
</div><p>Add a ra node id to a ra cluster's membership configuration
  This commits a join command to the leader log. After this has been replicated
  the leader will start replicating entries to the new node.
  This function returns after appending the command to the log.
 </p>

<h3 class="function"><a name="add_member-3">add_member/3</a></h3>
<div class="spec">
<p><tt>add_member(ServerRef::<a href="#type-ra_node_id">ra_node_id()</a>, NodeId::<a href="#type-ra_node_id">ra_node_id()</a>, Timeout::timeout()) -&gt; <a href="#type-ra_cmd_ret">ra_cmd_ret()</a></tt><br></p>
</div>
<p><b>See also:</b> <a href="#add_member-2">add_member/2</a>.</p>

<h3 class="function"><a name="cast-2">cast/2</a></h3>
<div class="spec">
<p><tt>cast(ServerRef::<a href="#type-ra_node_id">ra_node_id()</a>, Command::term()) -&gt; ok</tt><br></p>
</div><p>Cast a message to a node
  This is the least reliable way to interact with a ra node. If the node
  addressed isn't the leader no notification will be issued.</p>

<h3 class="function"><a name="cast-3">cast/3</a></h3>
<div class="spec">
<p><tt>cast(ServerRef::<a href="#type-ra_node_id">ra_node_id()</a>, Priority::normal | high, Command::term()) -&gt; ok</tt><br></p>
</div><p>Cast a message to a node with a priority
  This is the least reliable way to interact with a ra node. If the node
  addressed isn't the leader no notification will be issued.</p>

<h3 class="function"><a name="consistent_query-2">consistent_query/2</a></h3>
<div class="spec">
<p><tt>consistent_query(Node::<a href="#type-ra_node_id">ra_node_id()</a>, QueryFun::fun((term()) -&gt; term())) -&gt; {ok, {<a href="#type-ra_idxterm">ra_idxterm()</a>, term()}, <a href="#type-ra_node_id">ra_node_id()</a> | not_known}</tt><br></p>
</div><p>Query the state machine
  This allows a caller to query the state machine by appending the query
  to the log and returning the result once applied. This guarantees the
  result is consistent.</p>

<h3 class="function"><a name="consistent_query-3">consistent_query/3</a></h3>
<div class="spec">
<p><tt>consistent_query(Node::<a href="#type-ra_node_id">ra_node_id()</a>, QueryFun::fun((term()) -&gt; term()), Timeout::timeout()) -&gt; {ok, {<a href="#type-ra_idxterm">ra_idxterm()</a>, term()}, <a href="#type-ra_node_id">ra_node_id()</a> | not_known}</tt><br></p>
</div>

<h3 class="function"><a name="delete_cluster-1">delete_cluster/1</a></h3>
<div class="spec">
<p><tt>delete_cluster(NodeIds::[<a href="#type-ra_node_id">ra_node_id()</a>]) -&gt; {ok, <a href="#type-ra_node_id">ra_node_id()</a>} | {error, term()}</tt><br></p>
<p><tt>NodeIds</tt>: the ra_node_ids of the cluster<br>
</p>
<p>returns: <code>{ok | error, nodedown}</code></p>
</div><p>Deletes a ra cluster in an orderly fashion
  This function commits and end of life command which after each node applies
  it will cause that node to shut down and delete all it's data.
  The leader will stay up until it has successfully replicated the end of life
  command to all nodes after which it too will shut down and delete all it's
  data.</p>

<h3 class="function"><a name="delete_cluster-2">delete_cluster/2</a></h3>
<div class="spec">
<p><tt>delete_cluster(NodeIds::[<a href="#type-ra_node_id">ra_node_id()</a>], Timeout::timeout()) -&gt; {ok, Leader::<a href="#type-ra_node_id">ra_node_id()</a>} | {error, term()}</tt><br></p>
</div>
<p><b>See also:</b> <a href="#delete_cluster-1">delete_cluster/1</a>.</p>

<h3 class="function"><a name="delete_node-1">delete_node/1</a></h3>
<div class="spec">
<p><tt>delete_node(NodeId::<a href="#type-ra_node_id">ra_node_id()</a>) -&gt; ok | {error, term()}</tt><br></p>
<p><tt>NodeId</tt>: the ra_node_id() of the node<br>
</p>
<p>returns: <code>{ok | error, nodedown}</code></p>
</div><p>Deletes a ra node
  The node is forcefully deleted.</p>

<h3 class="function"><a name="leave_and_delete_node-1">leave_and_delete_node/1</a></h3>
<div class="spec">
<p><tt>leave_and_delete_node(NodeId) -&gt; any()</tt></p>
</div>

<h3 class="function"><a name="leave_and_delete_node-2">leave_and_delete_node/2</a></h3>
<div class="spec">
<p><tt>leave_and_delete_node(ServerRef::<a href="#type-ra_node_id">ra_node_id()</a>, NodeId::<a href="#type-ra_node_id">ra_node_id()</a>) -&gt; ok | timeout | {error, no_proc}</tt><br></p>
</div>

<h3 class="function"><a name="leave_and_delete_node-3">leave_and_delete_node/3</a></h3>
<div class="spec">
<p><tt>leave_and_delete_node(ServerRef::<a href="#type-ra_node_id">ra_node_id()</a>, NodeId::<a href="#type-ra_node_id">ra_node_id()</a>, Timeout::timeout()) -&gt; ok | timeout | {error, no_proc}</tt><br></p>
</div>

<h3 class="function"><a name="leave_and_terminate-1">leave_and_terminate/1</a></h3>
<div class="spec">
<p><tt>leave_and_terminate(NodeId) -&gt; any()</tt></p>
</div>

<h3 class="function"><a name="leave_and_terminate-2">leave_and_terminate/2</a></h3>
<div class="spec">
<p><tt>leave_and_terminate(ServerRef::<a href="#type-ra_node_id">ra_node_id()</a>, NodeId::<a href="#type-ra_node_id">ra_node_id()</a>) -&gt; ok | timeout | {error, no_proc}</tt><br></p>
</div>

<h3 class="function"><a name="leave_and_terminate-3">leave_and_terminate/3</a></h3>
<div class="spec">
<p><tt>leave_and_terminate(ServerRef::<a href="#type-ra_node_id">ra_node_id()</a>, NodeId::<a href="#type-ra_node_id">ra_node_id()</a>, Timeout::timeout()) -&gt; ok | timeout | {error, no_proc}</tt><br></p>
</div>

<h3 class="function"><a name="local_query-2">local_query/2</a></h3>
<div class="spec">
<p><tt>local_query(NodeId::<a href="#type-ra_node_id">ra_node_id()</a>, QueryFun::fun((term()) -&gt; term())) -&gt; {ok, {<a href="#type-ra_idxterm">ra_idxterm()</a>, term()}, <a href="#type-ra_node_id">ra_node_id()</a> | not_known}</tt><br></p>
</div><p>query the machine state on any node
  This allows you to run the QueryFun over the node machine state and
  return the result. Any ra node can be addressed.
  This can return infinitely stale results.</p>

<h3 class="function"><a name="local_query-3">local_query/3</a></h3>
<div class="spec">
<p><tt>local_query(NodeId::<a href="#type-ra_node_id">ra_node_id()</a>, QueryFun::fun((term()) -&gt; term()), Timeout::timeout()) -&gt; {ok, {<a href="#type-ra_idxterm">ra_idxterm()</a>, term()}, <a href="#type-ra_node_id">ra_node_id()</a> | not_known}</tt><br></p>
</div>

<h3 class="function"><a name="members-1">members/1</a></h3>
<div class="spec">
<p><tt>members(ServerRef::<a href="#type-ra_node_id">ra_node_id()</a>) -&gt; <a href="ra_node_proc.html#type-ra_leader_call_ret">ra_node_proc:ra_leader_call_ret</a>([<a href="#type-ra_node_id">ra_node_id()</a>])</tt><br></p>
</div><p>Query the members of a cluster</p>

<h3 class="function"><a name="members-2">members/2</a></h3>
<div class="spec">
<p><tt>members(ServerRef::<a href="#type-ra_node_id">ra_node_id()</a>, Timeout::timeout()) -&gt; <a href="ra_node_proc.html#type-ra_leader_call_ret">ra_node_proc:ra_leader_call_ret</a>([<a href="#type-ra_node_id">ra_node_id()</a>])</tt><br></p>
</div>

<h3 class="function"><a name="overview-0">overview/0</a></h3>
<div class="spec">
<p><tt>overview() -&gt; map()</tt><br></p>
</div><p>return a map of overview data of the ra system on the current erlang
  node.</p>

<h3 class="function"><a name="remove_member-2">remove_member/2</a></h3>
<div class="spec">
<p><tt>remove_member(ServerRef::<a href="#type-ra_node_id">ra_node_id()</a>, NodeId::<a href="#type-ra_node_id">ra_node_id()</a>) -&gt; <a href="#type-ra_cmd_ret">ra_cmd_ret()</a></tt><br></p>
<p><tt>ServerRef</tt>: the ra node to send the command to<br>
<tt>NodeId</tt>: the ra node id of the node to remove<br>
</p>
</div><p>Removes a node from the cluster's membership configuration
  This function returns after appending the command to the log.
 </p>

<h3 class="function"><a name="remove_member-3">remove_member/3</a></h3>
<div class="spec">
<p><tt>remove_member(ServerRef::<a href="#type-ra_node_id">ra_node_id()</a>, NodeId::<a href="#type-ra_node_id">ra_node_id()</a>, Timeout::timeout()) -&gt; <a href="#type-ra_cmd_ret">ra_cmd_ret()</a></tt><br></p>
</div>
<p><b>See also:</b> <a href="#remove_member-2">remove_member/2</a>.</p>

<h3 class="function"><a name="restart_node-1">restart_node/1</a></h3>
<div class="spec">
<p><tt>restart_node(NodeId::<a href="#type-ra_node_id">ra_node_id()</a>) -&gt; ok | {error, term()}</tt><br></p>
<p><tt>NodeId</tt>: the ra_node_id() of the node<br>
</p>
<p>returns: <code>{ok | error, Error}</code> when error can be
  <code>not_found</code> or <code>name_not_registered</code> when the ra node has never before
  been started on erlang node.</p>
</div><p>Restarts a previously succesfully started ra node</p>

<h3 class="function"><a name="send-2">send/2</a></h3>
<div class="spec">
<p><tt>send(Ref::<a href="#type-ra_node_id">ra_node_id()</a>, Data::term()) -&gt; <a href="#type-ra_cmd_ret">ra_cmd_ret()</a></tt><br></p>
</div>
<p><b>See also:</b> <a href="#send-3">send/3</a>.</p>

<h3 class="function"><a name="send-3">send/3</a></h3>
<div class="spec">
<p><tt>send(ServerRef::<a href="#type-ra_node_id">ra_node_id()</a>, Command::term(), Timeout::timeout()) -&gt; <a href="#type-ra_cmd_ret">ra_cmd_ret()</a></tt><br></p>
<p><tt>ServerRef</tt>: the ra node id of the node to send the commadn to.<br>
<tt>Command</tt>: the command, an arbitrary term that the current state
  machine can understand.<br>
<tt>Timeout</tt>: a timeout value<br>
</p>
<p>returns: <a href="#type-ra_cmd_ret"><code>ra_cmd_ret()</code></a></p>
</div><p>send a command to the ra node.
  if the ra node addressed isn't the leader and the leader is known
  it will automatically redirect the call to the leader node.
  This function returns after the command has been appended to the leader's
  raft log.
 </p>

<h3 class="function"><a name="send_and_await_consensus-2">send_and_await_consensus/2</a></h3>
<div class="spec">
<p><tt>send_and_await_consensus(Ref::<a href="#type-ra_node_id">ra_node_id()</a>, Data::term()) -&gt; <a href="#type-ra_cmd_ret">ra_cmd_ret()</a></tt><br></p>
</div>

<h3 class="function"><a name="send_and_await_consensus-3">send_and_await_consensus/3</a></h3>
<div class="spec">
<p><tt>send_and_await_consensus(Ref::<a href="#type-ra_node_id">ra_node_id()</a>, Data::term(), Timeout::timeout()) -&gt; <a href="#type-ra_cmd_ret">ra_cmd_ret()</a></tt><br></p>
<p><tt>Timeout</tt>: a timeout value<br>
</p>
<p>returns: <a href="#type-ra_cmd_ret"><code>ra_cmd_ret()</code></a></p>
</div><p>send a command to the ra node.
  if the ra node addressed isn't the leader and the leader is known
  it will automatically redirect the call to the leader node.
  This function returns after the command has been replicated and applied to
  the ra state machine. This is a fully synchronous interaction with the
  ra consensus system.
  Use this for low throughput actions where simple semantics are needed.
  if the state machine supports it it may return a result value which will
  be included in the result tuple.
 </p>

<h3 class="function"><a name="send_and_notify-3">send_and_notify/3</a></h3>
<div class="spec">
<p><tt>send_and_notify(ServerRef::<a href="#type-ra_node_id">ra_node_id()</a>, Command::term(), Correlation::term()) -&gt; ok</tt><br></p>
<p><tt>ServerRef</tt>: the ra node id of the node to send the commadn to.<br>
<tt>Command</tt>: the command, an arbitrary term that the current state
  machine can understand.<br>
</p>
<p>returns: <a href="#type-ra_cmd_ret"><code>ra_cmd_ret()</code></a></p>
</div><p><p>send a command to the ra node using cast.
  This will send a command to the ra node using a cast.
  if the node addressed isn't the leader the command will be discarded and
  and asyncronous notification message returned to the caller of the format:
  <code>{ra_event, ra_node_id(), {rejected, {not_leader, Correlation, LeaderId}}</code>.</p>
 
  If the node addressed is the leader the command will be appended to the log
  and replicated. Once it achieves consensus and asynchronous notification
  message of the format:
  <code>{ra_event, ra_node_id(), {applied, [Correlation]}}</code>
 </p>

<h3 class="function"><a name="send_and_notify-4">send_and_notify/4</a></h3>
<div class="spec">
<p><tt>send_and_notify(ServerRef::<a href="#type-ra_node_id">ra_node_id()</a>, Priority::high | normal, Command::term(), Correlation::term()) -&gt; ok</tt><br></p>
</div>

<h3 class="function"><a name="start-0">start/0</a></h3>
<div class="spec">
<p><tt>start() -&gt; ok</tt><br></p>
</div><p>Starts the ra application</p>

<h3 class="function"><a name="start_cluster-3">start_cluster/3</a></h3>
<div class="spec">
<p><tt>start_cluster(ClusterId::<a href="#type-ra_cluster_id">ra_cluster_id()</a>, Machine::<a href="ra_node.html#type-machine_conf">ra_node:machine_conf()</a>, NodeIds::[<a href="#type-ra_node_id">ra_node_id()</a>]) -&gt; {ok, [<a href="#type-ra_node_id">ra_node_id()</a>], [<a href="#type-ra_node_id">ra_node_id()</a>]} | {error, cluster_not_formed}</tt><br></p>
<p><tt>ClusterId</tt>: the cluster id of the cluster.<br>
<tt>Machine</tt>: The <a href="ra_machine.html#machine-0"><code>ra_machine:machine/0</code></a> configuration.<br>
<tt>NodeIds</tt>: The list of ra node ids.<br>
</p>
<p>returns: <p>
  <code>{ok, Started, NotStarted}</code>  if a cluster could be successfully
  started. A cluster can be successfully started if more than half of the
  nodes provided could be started. Nodes that could not be started need to
  be retried periodically using <a href="#start_node-1"><code>start_node/1</code></a></p>
 
  <p><code>{error, cluster_not_formed}</code> if a cluster could not be started.</p>
 
  If a cluster could not be formed any nodes that did manage to start are
  forcefully deleted.</p>
</div><p><p>Starts a new distributed ra cluster.</p>
 
 </p>

<h3 class="function"><a name="start_node-1">start_node/1</a></h3>
<div class="spec">
<p><tt>start_node(Conf::<a href="ra_node.html#type-ra_node_config">ra_node:ra_node_config()</a>) -&gt; ok | {error, term()}</tt><br></p>
<p><tt>Conf</tt>: a ra_node_config() configuration map.<br>
</p>
<p>returns: <code>{ok | error, Error}</code></p>
</div><p>Starts a ra node</p>

<h3 class="function"><a name="start_node-4">start_node/4</a></h3>
<div class="spec">
<p><tt>start_node(ClusterId::<a href="#type-ra_cluster_id">ra_cluster_id()</a>, NodeId::<a href="#type-ra_node_id">ra_node_id()</a>, Machine::<a href="ra_node.html#type-machine_conf">ra_node:machine_conf()</a>, NodeIds::[<a href="#type-ra_node_id">ra_node_id()</a>]) -&gt; ok | {error, term()}</tt><br></p>
</div>

<h3 class="function"><a name="start_or_restart_cluster-3">start_or_restart_cluster/3</a></h3>
<div class="spec">
<p><tt>start_or_restart_cluster(ClusterId::<a href="#type-ra_cluster_id">ra_cluster_id()</a>, Machine::<a href="ra_node.html#type-machine_conf">ra_node:machine_conf()</a>, RemNodes::[<a href="#type-ra_node_id">ra_node_id()</a>]) -&gt; {ok, [<a href="#type-ra_node_id">ra_node_id()</a>], [<a href="#type-ra_node_id">ra_node_id()</a>]} | {error, cluster_not_formed}</tt><br></p>
<p><tt>ClusterId</tt>: the cluster id of the cluster.<br>
<tt>Machine</tt>: The <a href="ra_machine.html#machine-0"><code>ra_machine:machine/0</code></a> configuration.<br>
</p>
<p>returns: <p>
  <code>{ok, Started, NotStarted}</code>  if a cluster could be successfully
  started. A cluster can be successfully started if more than half of the
  nodes provided could be started. Nodes that could not be started need to
  be retried periodically using <a href="#start_node-1"><code>start_node/1</code></a></p>
 
  <p><code>{error, cluster_not_formed}</code> if a cluster could not be started.</p>
 
  If there was no existing cluster and a new cluster could not be formed
  any nodes that did manage to start are
  forcefully deleted.</p>
</div><p><p>Starts or restarts a ra cluster.</p>
 
 </p>

<h3 class="function"><a name="stop_node-1">stop_node/1</a></h3>
<div class="spec">
<p><tt>stop_node(NodeId::<a href="#type-ra_node_id">ra_node_id()</a>) -&gt; ok | {error, nodedown}</tt><br></p>
<p><tt>NodeId</tt>: the ra_node_id() of the node<br>
</p>
<p>returns: <code>{ok | error, nodedown}</code></p>
</div><p>Stops a ra node</p>

<h3 class="function"><a name="trigger_election-1">trigger_election/1</a></h3>
<div class="spec">
<p><tt>trigger_election(NodeId::<a href="#type-ra_node_id">ra_node_id()</a>) -&gt; ok</tt><br></p>
<p><tt>NodeId</tt>: the ra node id of the node to trigger the election on.<br>
</p>
</div><p>Causes the node to entre the pre-vote and attempt become leader
  It is necessary to call this function when starting a new cluster as a
  branch new ra node will not automatically enter pre-vote by itself.
  Previously started nodes will however.
 </p>

<h3 class="function"><a name="trigger_election-2">trigger_election/2</a></h3>
<div class="spec">
<p><tt>trigger_election(NodeId::<a href="#type-ra_node_id">ra_node_id()</a>, Timeout::timeout()) -&gt; ok</tt><br></p>
</div>
<hr>

<div class="navbar"><a name="#navbar_bottom"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<p><i>Generated by EDoc</i></p>
</body>
</html>
